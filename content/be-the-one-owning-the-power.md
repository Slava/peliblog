Title: Be the one owning the power
Slug: be-the-one
Date: 2013-09-03

![The guy reading CLRS](https://d262ilb51hltx0.cloudfront.net/proxy/0*bHmjV5zv7u8DzQQm.jpeg)

I am an example of a self-taught software engineer. ‘Self-taught’ doesn't really mean I learnt everything on my own. Having had so many teachers, I just forgot about college. It doesn't mean there is nothing to learn, I am learning a lot everyday. And this piece of writing is directed towards those who are in the beginning of their learning cycle.

The following talks about the entire coding experience: the job you do, the things you try for fun, the project you have on weekends.

Programming came to my life through logical puzzles rather than websites and phone applications. It was [competitive programming](http://en.wikipedia.org/wiki/Competitive_programming): competition of writing the most efficient algorithm to solve a well-defined problem in a limited amount of time.

Having that experience, for a long time I was afraid of the industry: hours of writing verbose and dull code connecting a lot of pieces together didn't seem very interesting to me. My knowledge about the industry was very limited but this part was true: in a majority of projects you have to write heaps of tedious and repetitive code just connecting giant pieces of ready code together, “gluing” APIs of complex systems. Those work as magic boxes and the only thing left is to put them together. And that is the moment when our “programming skills” are applied.

My problem is not in frameworks doing all the hard job and taking “all the fun code” we could possibly write. Frameworks are great, general solutions are great, people who built them are great. Seriously, it takes a lot of effort to build a general purpose “thing” (database or drawing library, doesn't matter).

The problem to discuss is in us, beginning programmers and engineers. It’s really easy to get a false sense of incredible power coming from a great tool: you just learn a dozen of special commands to operate this beast and it builds the whole web-application for you! Beginner would feel an incredible leap forward from what he could do before.

It really takes you several days to learn a new technology you could possibly use in your next project and write a blog post about your progress. And the next day thousands of guys and girls will read the front page of Hacker News full of “How I connected X with Y and used it for 2 weeks, here are awesome micro-benchmarks” type of titles, where X and Y can be any of the modern mainstream technologies.

There is nothing bad in exploring those things. It’s just not the best thing to focus on as a beginner.

Learning the concepts is much more important.

_Learning ideas that allow the great solutions to come should precede blindly running through tens of technologies built on top of those ideas._

Once programmer understands the magic running inside another black box, he can find out magic doesn't exist, which may be the sad news for one but a lot of power to another. _Be the one owning the power._

I have seen this answer to the following question on [Quora](http://www.quora.com/Computer-Programming/What-are-the-things-you-wish-you-knew-when-you-started-programming-for-the-first-time): “What are the things you wish you knew when you started programming for the first time?”.
> That it's better to know more algorithms than more programming languages.

Good answer. But it goes further: get to know several programming languages, learn the paradigms behind them, discover the ways people come to these paradigms. It can go meta even further in all directions.

Every database has some fundamental principles shared across them. Those principles can be found in different categories. At the end of the day, we all know the clever things that came out of research and thinking based on a lot of both practical and theoretical knowledge.

Perhaps, after spending time investigating, researching and learning the fundamentals of databases you will better understand those benchmarks you measured last friday.

I met people of different ages and different experience claiming “you don't really need all that theoretical stuff”. A lot of people carelessly say kids don't need all that Computer Science stuff to become a programmer, nobody even goes to school. I hear it especially a lot as I am one of those kids who started coding without going to college, but I disagree.

One could argue: you certainly won't use all the CS curriculum got at college if you are building hundreds of websites looking alike, making small tweaks for every new client. If that’s what you want to do all your life — you are fine, but I have a different plan for myself.

Avoiding the “hard parts” of programming will never end well. One day such programmer will hit his limit of gluing database with a front-end framework and a search engine building CRUD applications. He will stop learning as he would think everything is already learnt. And after being bored for a while this programmer would start measuring the performance of another NoSQL database right before getting in the argument of big data future on a mailing list.

Please, don't do it. Evolve, discover new areas of programming. Again, not necessarily the new frameworks, but rather — the concepts, ideas, approaches people came up with over decades since machines were born.

You might think, all the theory from books and papers is boring and useless. But look around. Application of all the theory is really near you all the time. Have you ever wondered how the compiler works? How to implement your own toy programming language? How does git store your history and does it so fast and efficiently? How does the diff utility work? Won't it be fun to implement the differing algorithm on your own given the paper and detailed explanation? Can we build the modified version optimized for written text (words, sentences, paragraphs) rather than source code? How do social networks understand what news are relevant to us, can I build my own system of recommendations? You can start by “hacking” on these problems next weekend or commitment-free evening.

Further, you might find a gig that will allow you to explore new and challenging areas everyday. You might not want that but I do and that’s the plan for my education. The real and applied one.

This kind of learning really changed my view on the industry. I see myself growing as a software engineer and “making things” is also involved here. I really wish it came to me earlier.

I don't mean to dig textbooks all day, see, I actually encourage you do go and build things with your new knowledge.

